import React, { useEffect, useState } from "react";
import { GameState } from "./types";
import { levels } from "./levels";
import { Helper } from "./Helper";
import { GameField } from "./GameField";

const FIRST_LEVEL = 0;
const Game: React.FC = () => {
  const [gameState, setGameState] = useState(levels[FIRST_LEVEL]);
  const [history, setHistory] = useState<GameState[]>([levels[FIRST_LEVEL]]);
  const [currentLevel, setCurrentLevel] = useState(FIRST_LEVEL);

  const handleUndo = () => {
    if (history.length > 1) {
      const newHistory = [...history];
      const prevGameState = newHistory.pop();
      setHistory(newHistory);
      if (prevGameState) setGameState(prevGameState);
    }
  };

  const isLevelCompleted = () => {
    const boxes = gameState.boxes;
    const targets = gameState.targets;
    return boxes.every(box =>
      targets.some(target => target[0] === box[0] && target[1] === box[1])
    );
  };

  const isGameWon = () => {
    return currentLevel === levels.length - 1 && isLevelCompleted();
  };

  const handleNextLevel = () => {
    if (isLevelCompleted() && !isGameWon()) {
      setHistory([...history, levels[currentLevel + 1]]);
      setCurrentLevel(currentLevel + 1);
      setGameState(levels[currentLevel + 1]);
    }
  };

  function handleKeyDown(event: KeyboardEvent) {
    const playerPosition = gameState.playerPosition;
    const boxes = gameState.boxes;
    let direction: [number, number] = [0, 0];
    switch (event.key) {
      case "ArrowUp":
        direction = [-1, 0];
        break;
      case "ArrowDown":
        direction = [1, 0];
        break;
      case "ArrowLeft":
        direction = [0, -1];
        break;
      case "ArrowRight":
        direction = [0, 1];
        break;
      case "r":
        return handlePlayAgain();
      case "n":
        if (isLevelCompleted() && !isGameWon()) {
          setHistory([...history, levels[currentLevel + 1]]);
          setCurrentLevel(currentLevel + 1);
          setGameState(levels[currentLevel + 1]);
        }
        return;
        break;
      case "z":
        return handleUndo();
      default:
        return;
    }

    const [x, y] = direction;
    const newPlayerPosition = [
      playerPosition[0] + x,
      playerPosition[1] + y
    ] as [number, number];
    const newBoxes = boxes.map(box => [...box]) as [number, number][];
    let movedBox = newBoxes.findIndex(
      box => box[0] === newPlayerPosition[0] && box[1] === newPlayerPosition[1]
    );

    while (true) {
      if (movedBox === -1) {
        break;
      }

      const newBoxPosition = [
        newBoxes[movedBox][0] + x,
        newBoxes[movedBox][1] + y
      ] as [number, number];

      if (
        gameState.walls.some(
          wall => wall[0] === newBoxPosition[0] && wall[1] === newBoxPosition[1]
        )
      ) {
        break;
      }

      newBoxes[movedBox] = newBoxPosition;
      movedBox = newBoxes.findIndex(
        (box, boxIndex) =>
          boxIndex !== movedBox &&
          box[0] === newBoxPosition[0] &&
          box[1] === newBoxPosition[1]
      );
    }

    console.log(newBoxes, newPlayerPosition);
    if (
      gameState.walls.some(
        pos =>
          pos[0] === newPlayerPosition[0] && pos[1] === newPlayerPosition[1]
      ) ||
      newBoxes.some(
        pos =>
          pos[0] === newPlayerPosition[0] && pos[1] === newPlayerPosition[1]
      )
    ) {
      return;
    }

    setGameState(prevState => {
      setHistory([...history, prevState]);
      return {
        ...prevState,
        playerPosition: newPlayerPosition,
        boxes: newBoxes
      };
    });
  }

  function handlePlayAgain() {
    if (isGameWon()) {
      setCurrentLevel(FIRST_LEVEL);
      setHistory([levels[FIRST_LEVEL]]);
      setGameState(levels[FIRST_LEVEL]);
    } else {
      setHistory([...history, gameState]);
      setGameState(levels[currentLevel]);
    }
  }

  useEffect(() => {
    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [gameState]);

  return (
    <div>
      <h1>Sokoban Game (Mostly generated by ChatGPT)</h1>
      <GameField gameState={gameState} />
      <div className="controls">
        <button onClick={handleUndo}>Undo</button>
        <button onClick={handleNextLevel}>Next Level</button>
      </div>
      <div className="info">
        <p>
          Level: {currentLevel + 1} / {levels.length}
        </p>
        <p>
          {isGameWon()
            ? "You won!"
            : isLevelCompleted()
            ? "Level completed!"
            : ""}
        </p>
      </div>
      <Helper />
      <style>
        {`
            .controls {
                display: flex;
                justify-content: space-between;
                margin: 10px;
                width: 200px;
            }
            .info {
                margin: 10px;
            }
            `}
      </style>
    </div>
  );
};

export default Game;
